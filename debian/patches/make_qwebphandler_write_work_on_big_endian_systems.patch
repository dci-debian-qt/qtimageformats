From 88efc26966c75df099345a3ce9aa3c146ecfc9a7 Mon Sep 17 00:00:00 2001
From: Dmitry Shachnev <mitya57@gmail.com>
Date: Thu, 29 May 2014 10:58:33 +0400
Subject: [PATCH] Make QWebpHandler::write() work on big endian systems

Currently, we convert image to Format_ARGB32. This means that on big
endian systems the order of bytes will be (0xAA, 0xRR, 0xGG, 0xBB).
However, in WebP library there is no function to import bytes in
ARGB format.

This commit makes us use Format_RGBA8888 and WebPPictureImportRGBA
on big endian systems, which will make the function work correctly.

Change-Id: I5f347f3ec66f0a57df0d40d4900b1573f9400506
---
 src/plugins/imageformats/webp/qwebphandler.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/src/plugins/imageformats/webp/qwebphandler.cpp b/src/plugins/imageformats/webp/qwebphandler.cpp
index 8834820..599cb00 100644
--- a/src/plugins/imageformats/webp/qwebphandler.cpp
+++ b/src/plugins/imageformats/webp/qwebphandler.cpp
@@ -137,8 +137,13 @@ bool QWebpHandler::write(const QImage &image)
     }
 
     QImage srcImage = image;
+#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
     if (srcImage.format() != QImage::Format_ARGB32)
         srcImage = srcImage.convertToFormat(QImage::Format_ARGB32);
+#else /* Q_BIG_ENDIAN */
+    if (srcImage.format() != QImage::Format_RGBA8888)
+        srcImage = srcImage.convertToFormat(QImage::Format_RGBA8888);
+#endif
 
     WebPPicture picture;
     WebPConfig config;
@@ -151,7 +156,11 @@ bool QWebpHandler::write(const QImage &image)
     picture.width = srcImage.width();
     picture.height = srcImage.height();
     picture.use_argb = 1;
+#if Q_BYTE_ORDER == Q_LITTLE_ENDIAN
     if (!WebPPictureImportBGRA(&picture, srcImage.bits(), srcImage.bytesPerLine())) {
+#else /* Q_BIG_ENDIAN */
+    if (!WebPPictureImportRGBA(&picture, srcImage.bits(), srcImage.bytesPerLine())) {
+#endif
         qWarning() << "failed to import image data to webp picture.";
 
         WebPPictureFree(&picture);
-- 
2.0.0

